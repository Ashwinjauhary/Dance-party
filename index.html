<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Auto Dance Party 3D</title>
    <!-- Import Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Import OrbitControls -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        :root {
            --bg-color: #1a1a2e;
            --accent: #ff2e63;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg-color);
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            touch-action: none; /* Prevent scroll on mobile while dragging canvas */
        }

        /* 3D Container */
        #stage {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            outline: none;
        }

        /* Overlay UI */
        .overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            transition: opacity 0.5s;
            padding: 20px;
            box-sizing: border-box;
            text-align: center;
        }

        h1 {
            font-size: clamp(2rem, 8vw, 4rem); /* Responsive font size */
            text-transform: uppercase;
            background: linear-gradient(to right, #fff, #08d9d6, #ff2e63);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin: 0 0 20px 0;
            text-shadow: 0 0 20px rgba(8, 217, 214, 0.5);
            line-height: 1.2;
        }

        button {
            padding: 15px 40px;
            font-size: clamp(1.2rem, 4vw, 1.5rem);
            background: var(--accent);
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 0 20px rgba(255, 46, 99, 0.6);
            transition: transform 0.2s, box-shadow 0.2s;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }

        button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(255, 46, 99, 0.9);
        }

        button:active {
            transform: scale(0.95);
        }

        .instructions {
            margin-top: 20px;
            color: #aaa;
            font-size: 0.9rem;
            max-width: 400px;
            line-height: 1.5;
        }

        .hidden {
            opacity: 0;
            pointer-events: none;
        }

        /* Mobile controls hint */
        .control-hint {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            color: rgba(255,255,255,0.5);
            font-size: 0.8rem;
            pointer-events: none;
            z-index: 10;
            opacity: 0;
            transition: opacity 1s;
        }
        .show-hint {
            opacity: 1;
        }
    </style>
</head>
<body>

    <div class="overlay" id="overlay">
        <h1>3D Dance Party</h1>
        <button id="startBtn">Start Party</button>
        <p class="instructions">
            ⚠️ Warning: Flashing Lights & Audio<br>
            Drag to rotate • Pinch to zoom
        </p>
    </div>

    <div id="stage"></div>
    <div class="control-hint" id="hint">Drag to Rotate</div>

    <script>
        const startBtn = document.getElementById('startBtn');
        const overlay = document.getElementById('overlay');
        const hint = document.getElementById('hint');
        
        // Audio Variables
        let audioCtx;
        let analyser;
        let isPlaying = false;
        
        // Three.js Variables
        let scene, camera, renderer, controls;
        let dancers = []; 
        let gridHelper;
        let lights = [];

        // --- 3D SCENE SETUP ---
        function initThree() {
            const stage = document.getElementById('stage');
            
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);
            scene.fog = new THREE.Fog(0x1a1a2e, 10, 60);

            // Camera
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 8, 25); // Moved back slightly for better mobile view

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Cap pixel ratio for performance
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            stage.appendChild(renderer.domElement);

            // Controls (OrbitControls)
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; // Smooth motion
            controls.dampingFactor = 0.05;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 1.0;
            controls.minDistance = 5;
            controls.maxDistance = 50;
            controls.maxPolarAngle = Math.PI / 2 - 0.05; // Prevent going below floor
            controls.target.set(0, 2, 0);

            // Floor Grid
            gridHelper = new THREE.GridHelper(60, 60, 0xff2e63, 0x333333);
            scene.add(gridHelper);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 1.5); 
            scene.add(ambientLight);

            // Moving colored spotlights
            createSpotlight(0xff2e63, -10, 15, 5);
            createSpotlight(0x08d9d6, 10, 15, 5);
            createSpotlight(0x9d00ff, 0, 15, -10);

            // Create Characters (Type, Color, X Position, Z Position)
            createCharacter('box', 0x08d9d6, -6, 0);       // Left Mid
            createCharacter('sphere', 0xff2e63, 0, 2);      // Center Lead
            createCharacter('cone', 0x9d00ff, 6, 0);        // Right Mid
            createCharacter('torus', 0xffaa00, -10, -3);    // Far Left Back
            createCharacter('cylinder', 0x00ff00, 10, -3);  // Far Right Back

            // Handle Resize
            window.addEventListener('resize', onWindowResize, false);
            
            // Show hint briefly
            setTimeout(() => hint.classList.add('show-hint'), 500);
            setTimeout(() => hint.classList.remove('show-hint'), 4000);
        }

        function createSpotlight(color, x, y, z) {
            const spotLight = new THREE.SpotLight(color, 1);
            spotLight.position.set(x, y, z);
            spotLight.angle = 0.4;
            spotLight.penumbra = 0.5;
            spotLight.decay = 2;
            spotLight.distance = 50;
            spotLight.castShadow = true;
            spotLight.shadow.mapSize.width = 1024;
            spotLight.shadow.mapSize.height = 1024;
            scene.add(spotLight);
            lights.push(spotLight);
        }

        function createCharacter(type, color, x, z) {
            const group = new THREE.Group();
            group.position.set(x, 0, z);

            let geometry;
            let yOffset = 1.5;

            // Define Geometry based on type
            switch(type) {
                case 'box':
                    geometry = new THREE.BoxGeometry(2.5, 2.5, 2.5);
                    yOffset = 1.25;
                    break;
                case 'sphere':
                    geometry = new THREE.IcosahedronGeometry(1.8, 1); // Low poly sphere look
                    yOffset = 1.8;
                    break;
                case 'cone':
                    geometry = new THREE.ConeGeometry(1.5, 3.5, 32);
                    yOffset = 1.75;
                    break;
                case 'torus':
                    geometry = new THREE.TorusKnotGeometry(1, 0.3, 100, 16);
                    yOffset = 2;
                    break;
                case 'cylinder':
                    geometry = new THREE.CylinderGeometry(1, 1, 3, 32);
                    yOffset = 1.5;
                    break;
            }

            const material = new THREE.MeshStandardMaterial({ 
                color: color, 
                roughness: 0.3,
                metalness: 0.2,
                emissive: color,
                emissiveIntensity: 0.1
            });

            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.y = yOffset;
            mesh.castShadow = true;
            group.add(mesh);

            // Add Eyes to make them characters
            addEyes(group, type, yOffset);

            scene.add(group);

            // Store ref for animation
            dancers.push({
                group: group,
                mesh: mesh,
                type: type,
                baseY: yOffset,
                baseScale: 1
            });
        }

        function addEyes(group, type, yOffset) {
            const eyeGeo = new THREE.SphereGeometry(0.35, 16, 16);
            const eyeMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const pupilGeo = new THREE.SphereGeometry(0.15, 16, 16);
            const pupilMat = new THREE.MeshBasicMaterial({ color: 0x000000 });

            function createEye(x) {
                const eyeGroup = new THREE.Group();
                const white = new THREE.Mesh(eyeGeo, eyeMat);
                const black = new THREE.Mesh(pupilGeo, pupilMat);
                black.position.z = 0.25; 
                eyeGroup.add(white, black);
                eyeGroup.position.set(x, yOffset + 0.2, 0.8); 
                
                if(type === 'box') eyeGroup.position.z = 1.3;
                if(type === 'cone') {
                    eyeGroup.position.y = yOffset - 0.5; 
                    eyeGroup.position.z = 0.8;
                }
                if(type === 'sphere') eyeGroup.position.z = 1.5;
                if(type === 'cylinder') eyeGroup.position.z = 1.0;
                if(type === 'torus') {
                     eyeGroup.position.z = 0.5;
                     eyeGroup.position.y = yOffset + 0.5;
                }
                return eyeGroup;
            }
            group.add(createEye(-0.5));
            group.add(createEye(0.5));
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- MUSIC GENERATION (Web Audio API) ---
        
        function initAudio() {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            audioCtx = new AudioContext();
            analyser = audioCtx.createAnalyser();
            analyser.fftSize = 256; 
            
            const masterGain = audioCtx.createGain();
            masterGain.gain.value = 0.3;
            masterGain.connect(audioCtx.destination);
            
            analyser.connect(masterGain);

            // Unlock audio on mobile
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }

            startSequencer(analyser);
        }

        function createKick(time, dest) {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(dest);
            osc.frequency.setValueAtTime(150, time);
            osc.frequency.exponentialRampToValueAtTime(0.01, time + 0.5);
            gain.gain.setValueAtTime(1, time);
            gain.gain.exponentialRampToValueAtTime(0.01, time + 0.5);
            osc.start(time);
            osc.stop(time + 0.5);
        }

        function createSnare(time, dest) {
            const bufferSize = audioCtx.sampleRate * 0.5;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
            const noise = audioCtx.createBufferSource();
            noise.buffer = buffer;
            const filter = audioCtx.createBiquadFilter();
            filter.type = 'highpass';
            filter.frequency.value = 1000;
            const gain = audioCtx.createGain();
            noise.connect(filter);
            filter.connect(gain);
            gain.connect(dest);
            gain.gain.setValueAtTime(0.7, time);
            gain.gain.exponentialRampToValueAtTime(0.01, time + 0.2);
            noise.start(time);
            noise.stop(time + 0.2);
        }

        function createHiHat(time, dest) {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'square';
            const filter = audioCtx.createBiquadFilter();
            filter.type = 'highpass';
            filter.frequency.value = 8000;
            osc.connect(filter);
            filter.connect(gain);
            gain.connect(dest);
            osc.frequency.setValueAtTime(8000, time);
            gain.gain.setValueAtTime(0.3, time);
            gain.gain.exponentialRampToValueAtTime(0.01, time + 0.05);
            osc.start(time);
            osc.stop(time + 0.05);
        }

        function createBass(time, freq, dest) {
            const osc = audioCtx.createOscillator();
            osc.type = 'sawtooth';
            const gain = audioCtx.createGain();
            const filter = audioCtx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(300, time);
            filter.frequency.linearRampToValueAtTime(100, time + 0.3);
            osc.connect(filter);
            filter.connect(gain);
            gain.connect(dest);
            osc.frequency.setValueAtTime(freq, time);
            gain.gain.setValueAtTime(0.4, time);
            gain.gain.linearRampToValueAtTime(0, time + 0.4);
            osc.start(time);
            osc.stop(time + 0.4);
        }

        function startSequencer(dest) {
            let nextNoteTime = audioCtx.currentTime + 0.1;
            let beatCount = 0;
            const tempo = 125; 
            const secondsPerBeat = 60.0 / tempo;
            const lookahead = 25.0; 
            const scheduleAheadTime = 0.1; 

            function scheduler() {
                while (nextNoteTime < audioCtx.currentTime + scheduleAheadTime) {
                    scheduleNote(beatCount, nextNoteTime, dest);
                    nextNoteTime += secondsPerBeat / 4; 
                    beatCount++;
                }
                if(isPlaying) setTimeout(scheduler, lookahead);
            }

            function scheduleNote(beatNumber, time, dest) {
                const step = beatNumber % 16;
                if (step % 4 === 0) createKick(time, dest);
                if (step === 4 || step === 12) createSnare(time, dest);
                if (step % 2 !== 0) createHiHat(time, dest);
                
                // Funky Bassline
                if (step === 0) createBass(time, 55, dest); 
                if (step === 2) createBass(time, 55, dest);
                if (step === 8) createBass(time, 65.41, dest); 
                if (step === 10) createBass(time, 49, dest); 
                if (step === 14) createBass(time, 73.42, dest); 
            }
            scheduler();
        }

        // --- ANIMATION LOOP ---

        function animate() {
            if (!isPlaying) return;
            requestAnimationFrame(animate);

            // Update Controls (Auto-rotate / Damping)
            if (controls) controls.update();

            // Get Audio Data
            const dataArray = new Uint8Array(analyser.frequencyBinCount);
            analyser.getByteFrequencyData(dataArray);

            const bass = getAverageVolume(dataArray, 0, 10);
            const mid = getAverageVolume(dataArray, 10, 50);
            const treble = getAverageVolume(dataArray, 50, 100);

            // Animate Dancers
            dancers.forEach((d, i) => {
                let energy = 0;
                
                if (i === 1) energy = bass; 
                else if (i === 0 || i === 2) energy = mid; 
                else energy = treble; 

                const normEnergy = energy / 255; 

                // Jump
                d.group.position.y = (normEnergy * 2); 

                // Squash/Stretch
                const scaleY = 1 + (normEnergy * 0.5);
                const scaleXZ = 1 - (normEnergy * 0.2); 
                d.mesh.scale.set(scaleXZ, scaleY, scaleXZ);

                // Rotate Mesh (Internal rotation, separate from camera orbit)
                d.mesh.rotation.y += 0.01 + (normEnergy * 0.1);
                d.mesh.rotation.x = Math.sin(Date.now() * 0.005) * 0.5 * normEnergy;

                // Glow
                d.mesh.material.emissiveIntensity = 0.1 + (normEnergy * 1.5);
            });

            // Light flashing on heavy bass
            if (bass > 220) {
                scene.background = new THREE.Color(0x251a3a);
            } else {
                scene.background = new THREE.Color(0x1a1a2e);
            }

            renderer.render(scene, camera);
        }

        function getAverageVolume(array, start, end) {
            let values = 0;
            for (let i = start; i < end; i++) values += array[i];
            return values / (end - start);
        }

        // --- EVENTS ---

        startBtn.addEventListener('click', () => {
            overlay.classList.add('hidden');
            isPlaying = true;
            initThree(); 
            initAudio(); 
            animate();   
        });

    </script>
</body>
</html>
